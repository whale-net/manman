import logging
import os
from typing import Optional

import sqlalchemy
import typer
import uvicorn
from typing_extensions import Annotated

import alembic
import alembic.command
import alembic.config
from manman.host.api import fastapp
from manman.util import (
    get_sqlalchemy_engine,
    init_sql_alchemy_engine,
)

app = typer.Typer()
# fileConfig("logging.ini", disable_existing_loggers=False)
logger = logging.getLogger(__name__)


@app.command()
def start(
    # auth_url: Annotated[str, typer.Option(envvar="MANMAN_AUTH_URL")],
    port: int = 8000,
    # workers: int = 1,
    # auto_reload: bool = False,
    should_run_migration_check: Optional[bool] = True,
):
    if should_run_migration_check and _need_migration():
        raise RuntimeError("migration needs to be ran before starting")

    # init_auth_api_client(auth_url)

    # TODO running via string doesn't initialize engine because separate process
    # TODO - does running in this way cause blocking issues with concurrent requests?
    # this would be a nice development enhancement, but may not matter if we scale out. TBD
    # gunicorn + uvicorn worker is preferred if need to scale local api instance
    # uvicorn.run("manman.host.api:fastapp", port=port, workers=workers, reload=auto_reload)
    uvicorn.run(fastapp, port=port)


# TODO - should these not be ran by host?
@app.command()
def run_migration():
    _run_migration(get_sqlalchemy_engine())


@app.command()
def create_migration(migration_message: Optional[str] = None):
    # TODO - make use of this? or remove
    if os.environ.get("ENVIRONMENT", "DEV") == "PROD":
        raise RuntimeError("cannot create revisions in production")
    _create_migration(get_sqlalchemy_engine(), message=migration_message)


@app.callback()
def callback(
    db_connection_string: Annotated[str, typer.Option(envvar="MANMAN_POSTGRES_URL")],
):
    init_sql_alchemy_engine(db_connection_string)


# alembic helpers
# TODO context manager to reduce duplication
# TODO - figure out what I meant with the previous TODO
def _get_alembic_config() -> alembic.config.Config:
    alembic_path = "./alembic.ini"
    config = alembic.config.Config(alembic_path)
    return config


def _need_migration() -> bool:
    config = _get_alembic_config()
    engine = get_sqlalchemy_engine()
    with engine.begin() as conn:
        # TODO remove connection from env and use this?
        config.attributes["connection"] = conn
        try:
            alembic.command.check(config)
        except alembic.command.util.AutogenerateDiffsDetected:
            return True

        return False


def _run_migration(engine: sqlalchemy.Engine):
    config = _get_alembic_config()
    # with engine.begin() as conn:
    # config.attributes["connection"] = conn
    alembic.command.upgrade(config, "head")


def _create_migration(engine: sqlalchemy.Engine, message: Optional[str] = None):
    if not _need_migration():
        raise RuntimeError("no migration creation required")

    config = _get_alembic_config()
    # with engine.begin() as conn:
    # config.attributes["connection"] = conn
    alembic.command.revision(config, message=message, autogenerate=True)
