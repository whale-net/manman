import logging
import os
from typing import Optional

import alembic
import alembic.command
import alembic.config
import sqlalchemy
import typer
import uvicorn
from typing_extensions import Annotated

from manman.host.api import fastapp
from manman.util import (
    get_rabbitmq_ssl_options,
    get_sqlalchemy_engine,
    init_rabbitmq,
    init_sql_alchemy_engine,
)

app = typer.Typer()
# fileConfig("logging.ini", disable_existing_loggers=False)
logger = logging.getLogger(__name__)


@app.command()
def start(
    rabbitmq_host: Annotated[str, typer.Option(envvar="MANMAN_RABBITMQ_HOST")],
    rabbitmq_port: Annotated[int, typer.Option(envvar="MANMAN_RABBITMQ_PORT")],
    rabbitmq_username: Annotated[str, typer.Option(envvar="MANMAN_RABBITMQ_USER")],
    rabbitmq_password: Annotated[str, typer.Option(envvar="MANMAN_RABBITMQ_PASSWORD")],
    app_env: Annotated[Optional[str], typer.Option(envvar="APP_ENV")] = None,
    # auth_url: Annotated[str, typer.Option(envvar="MANMAN_AUTH_URL")],
    port: int = 8000,
    # workers: int = 1,
    # auto_reload: bool = False,
    should_run_migration_check: Optional[bool] = True,
    enable_ssl: Annotated[
        bool, typer.Option(envvar="MANMAN_RABBITMQ_ENABLE_SSL")
    ] = False,
    rabbitmq_ssl_hostname: Annotated[
        str, typer.Option(envvar="MANMAN_RABBITMQ_SSL_HOSTNAME")
    ] = None,
):
    if should_run_migration_check and _need_migration():
        raise RuntimeError("migration needs to be ran before starting")
    # init_auth_api_client(auth_url)

    virtual_host = f"manman-{app_env}" if app_env else "/"

    # Initialize with AMQPStorm connection parameters
    init_rabbitmq(
        host=rabbitmq_host,
        port=rabbitmq_port,
        username=rabbitmq_username,
        password=rabbitmq_password,
        virtual_host=virtual_host,
        ssl_enabled=enable_ssl,
        ssl_options=get_rabbitmq_ssl_options(
            hostname=rabbitmq_ssl_hostname,
        )
        if enable_ssl
        else None,
    )

    # TODO running via string doesn't initialize
    # engine because separate process
    # TODO - does running in this way cause blocking
    # issues with concurrent requests?
    # this would be a nice development enhancement,
    # but may not matter if we scale out. TBD
    # gunicorn + uvicorn worker is preferred if
    # need to scale local api instance
    # uvicorn.run("manman.host.api:fastapp",
    #  port=port, workers=workers, reload=auto_reload)
    uvicorn.run(fastapp, host="0.0.0.0", port=port)


# TODO - should these not be ran by host?
@app.command()
def run_migration():
    _run_migration(get_sqlalchemy_engine())


@app.command()
def create_migration(migration_message: Optional[str] = None):
    # TODO - make use of this? or remove
    if os.environ.get("ENVIRONMENT", "DEV") == "PROD":
        raise RuntimeError("cannot create revisions in production")
    _create_migration(get_sqlalchemy_engine(), message=migration_message)


@app.command()
def run_downgrade(target: str):
    config = _get_alembic_config()
    engine = get_sqlalchemy_engine()
    with engine.begin() as conn:
        config.attributes["connection"] = conn
        alembic.command.downgrade(config, target)


@app.callback()
def callback(
    db_connection_string: Annotated[str, typer.Option(envvar="MANMAN_POSTGRES_URL")],
):
    init_sql_alchemy_engine(db_connection_string)


# alembic helpers
# TODO context manager to reduce duplication
# TODO - figure out what I meant with the previous TODO
def _get_alembic_config() -> alembic.config.Config:
    alembic_path = "./alembic.ini"
    config = alembic.config.Config(alembic_path)
    return config


def _need_migration() -> bool:
    config = _get_alembic_config()
    engine = get_sqlalchemy_engine()
    with engine.begin() as conn:
        # TODO remove connection from env and use this?
        config.attributes["connection"] = conn
        try:
            alembic.command.check(config)
        except alembic.command.util.AutogenerateDiffsDetected:
            return True

        return False


def _run_migration(engine: sqlalchemy.Engine):
    config = _get_alembic_config()
    # with engine.begin() as conn:
    # config.attributes["connection"] = conn
    alembic.command.upgrade(config, "head")


def _create_migration(engine: sqlalchemy.Engine, message: Optional[str] = None):
    if not _need_migration():
        raise RuntimeError("no migration creation required")

    config = _get_alembic_config()
    # with engine.begin() as conn:
    # config.attributes["connection"] = conn
    alembic.command.revision(config, message=message, autogenerate=True)
